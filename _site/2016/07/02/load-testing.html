<!DOCTYPE html>
<html>
  <head>
    <!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Load Testing - Philibert&#8217;s website</title>
<meta property="og:title" content="Load Testing" />
<meta name="description" content="Elt, Elixir load testing" />
<meta property="og:description" content="Elt, Elixir load testing" />
<meta property="og:site_name" content="Philibert’s website" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-07-02T00:00:00-04:00" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Load Testing",
    "datePublished": "2016-07-02T00:00:00-04:00",
    "description": "Elt, Elixir load testing",
    "url": "/2016/07/02/load-testing.html"
  }
</script>
<!-- End Jekyll SEO tag -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="keywords" content="Philibert Dugas, Philibertd">
    <meta name="author" content="Philibert Dugas">
    <link href="/favicon.ico" rel="shortcut icon" type="image/x-icon">
    <link href="/static/css/skeleton.css" rel="stylesheet">
    <link href="/static/css/style.css" rel="stylesheet">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-76867217-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div class="container">
  <div class="row">
    <div class="profile three columns">
      <a href="/"><img id="avatar" src="/static/images/phili.png" alt="avatar"/></a>
      <ul id="social">
        <li>
          <a href="https://ca.linkedin.com/in/philibertdugas" target="_blank"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M365 1414h231v-694h-231v694zm246-908q-1-52-36-86t-93-34-94.5 34-36.5 86q0 51 35.5 85.5t92.5 34.5h1q59 0 95-34.5t36-85.5zm585 908h231v-398q0-154-73-233t-193-79q-136 0-209 117h2v-101h-231q3 66 0 694h231v-388q0-38 7-56 15-35 45-59.5t74-24.5q116 0 116 157v371zm468-998v960q0 119-84.5 203.5t-203.5 84.5h-960q-119 0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5 84.5t84.5 203.5z"/></svg></a>
        </li>
        <li>
          <a href="https://github.com/PhilibertDugas" target="_blank"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5t-203.5 84.5h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105 20.5-150.5q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27t-83.5-38.5-86-13.5q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5-55.5-62.5q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5h-224q-119 0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5 84.5t84.5 203.5z"/></svg></a>
        </li>
        <li>
          <a href="https://twitter.com/DugasPhilibert" target="_blank"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1408 610q-56 25-121 34 68-40 93-117-65 38-134 51-61-66-153-66-87 0-148.5 61.5t-61.5 148.5q0 29 5 48-129-7-242-65t-192-155q-29 50-29 106 0 114 91 175-47-1-100-26v2q0 75 50 133.5t123 72.5q-29 8-51 8-13 0-39-4 21 63 74.5 104t121.5 42q-116 90-261 90-26 0-50-3 148 94 322 94 112 0 210-35.5t168-95 120.5-137 75-162 24.5-168.5q0-18-1-27 63-45 105-109zm256-194v960q0 119-84.5 203.5t-203.5 84.5h-960q-119 0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5 84.5t84.5 203.5z"/></svg></a>
        </li>
      </ul>
      <h2>Philibert Dugas</h2>
      <h6>Developer <a href="https://www.shopify.ca/">@Shopify</a>, software enthusiast</h6>
    </div>
    <div class="nine columns content">
      <article>
  <h2 id="elt-elixir-load-testing">Elt, Elixir load testing</h2>

<p><em>July 2nd, 2016</em></p>

<p>Back in late 2015, I came across this code review assigned to me. Over 500 lines of XML code written by a colleague QA at the time, a JMeter load testing scenario.
No way I could understand everything going on in there, so I decided I’d try this scenario on my local machine.</p>

<p>Checkout the branch, kick off the JMeter repulsive GUI, start the test. Computer crashed in around 30 seconds.
There were two main problems with this. First, the scenario itself was hard to review because of the XML syntax.
Second, it was difficult to run the scenario locally as the JMeter would take too much resources on the computer.</p>

<p>That’s when I started creating <a href="https://github.com/dudang/golt">Golt</a>. It’s purpose was to fix those two problems specifically.
The test scenarios are in YAML or JSON format, which is much more reviewable.
The program itself uses Go to leverage it’s lightweight threading system.
I found this to be a great project to learn Go. Not a trivial application, but nothing too complex neither. While I never got to use Golt back at work, I enjoyed the learning process.</p>

<p>I decided I want to do the same thing with Elixir. Writing a load tester which uses YAML or JSON as an input. When I read the following lines in the Elixir getting started’s guide, it convinced me even more:</p>

<blockquote>
  <p><em>Elixir’s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (unlike threads in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.</em></p>
</blockquote>

<p>So here I go. The first step this week was to send HTTP requests without worrying about parsing YAML or JSON. While searching about how to send HTTP requests in Elixir, I found <a href="https://github.com/myfreeweb/httpotion">HTTPotion</a>. This client interesting as it supported asynchronous requests out of the box. I decided to build a module around it to see how it goes.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/c22881b7a07038b2ccacadff357f06c1.js"> </script>

<p>This module serves provides two functions. The first one sends a request and streams it’s result to a receiver process. The second one boots a receiver process and returns it’s PID. This first iteration turned out to be wrong:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iex&gt; {:ok, pid} = HTTPSender.receive_request
{:ok, #PID&lt;0.134.0&gt;}

iex&gt; HTTPSender.send_request("http://philibertd.com", pid)
%HTTPotion.AsyncResponse{id: -576460752303423304}
** (EXIT from #PID&lt;0.159.0&gt;) an exception was raised:
    ** (KeyError) key :to_string not found in: %HTTPotion.AsyncHeaders
</code></pre>
</div>

<p>Right, so I can’t cast the <code class="highlighter-rouge">AsyncHeaders</code> struct to string. Let’s adjust this and match the documented structs:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/b453845c928864495185d04325ec7d5b.js"> </script>

<p>Here, I’m using using pattern matching to extract the information I want. In this case, the status code from the headers and the chunk content. The second try went this way:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iex&gt; {:ok, pid} = HTTPSender.receive_request
{:ok, #PID&lt;0.134.0&gt;}

iex&gt; HTTPSender.send_request("http://philibertd.com", pid)
%HTTPotion.AsyncResponse{id: -576460752303423304}
200
</code></pre>
</div>

<p>So we see some improvements here. We received the <code class="highlighter-rouge">AsyncHeaders</code> and it printed out the status code value. Problem is, we didn’t handle the <code class="highlighter-rouge">AsyncChunk</code> and <code class="highlighter-rouge">AsyncEnd</code>. Turns out that a <code class="highlighter-rouge">Task</code> will execute the function and stop afterwards. Since the response is sent in 3 different messages, we want to loop until we receive the <code class="highlighter-rouge">AsyncEnd</code> message.</p>

<p>The final iteration looks like this:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/06a381853f4fa4e552296865a065dc45.js"> </script>

<p>In this example, we introduced a new private function <code class="highlighter-rouge">loop</code>. This function starts by receiving the messages from the http response. It then loops until it receives the <code class="highlighter-rouge">AsyncEnd</code> message at which points it stops. Since we’re doing functional programming, looping is actually recursion! Note that our public method now doesn’t define the logic in it’s <code class="highlighter-rouge">Task.start_link</code>. It delegates to <code class="highlighter-rouge">loop</code> which is cleaner in my opinion:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>iex&gt; {:ok, pid} = HTTPSender.receive_request
{:ok, #PID<span class="nt">&lt;0</span><span class="err">.</span><span class="na">134</span><span class="err">.</span><span class="na">0</span><span class="nt">&gt;</span>}

iex&gt; HTTPSender.send_request("http://philibertd.com", pid)
%HTTPotion.AsyncResponse{id: -576460752303423487}
200
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="c">&lt;!-- Begin Jekyll SEO tag v2.0.0 --&gt;</span>
<span class="nt">&lt;title&gt;</span>Philibert’s website<span class="nt">&lt;/title&gt;</span>
........
end
</code></pre>
</div>

<p>We send the request out and are able to match all 3 messages! To make the output more readable, I trimmed down the chunk of the response. Now that we are able to send asynchronous http requests, the next step is to build a test plan and parse it. I’ll be doing this in the next post!</p>

</article>

<p>You can find me on Twitter <a href="https://twitter.com/DugasPhilibert">@DugasPhilibert</a></p>

    </div>
  </div>
</div>

  </body>
</html>
